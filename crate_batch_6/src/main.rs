use std::panic;

// *** main start
fn main() {
    println!("running crate batch 6");
    run_1();
    run_2();
    run_3();
    run_4();
    run_5();
    run_6();
    run_7();
    // run_8();
    run_9();
    run_10();
    run_11();
    run_12();
    run_13();
    run_14();
    run_15();
    run_16();
    println!("ending crate batch 6");
}
// *** main end

fn run_1() {
    println!("run 1");
    // ! crashing input
    // let data = "{#}";
    let data = "{}";

    let mut tpl = tinytemplate::TinyTemplate::new();

    let _ = tpl.add_template("template", data);
}

use todotxt::Task;
fn run_2() {
    println!("run 2");
    let data = b"2021-01-01 This is a task +project @context";
    if let Ok(line) = std::str::from_utf8(data) {
        let _: Result<Task, _> = line.parse();
    }
}

use tokei::{ Config, LanguageType, Languages };
fn run_3() {
    println!("run 3");
    // ? line 196 197 are same function (Tokei)
    // The input content causing the panic.
    let buggy_input = b"<script>\ra </script>";
    let language = LanguageType::Vue;
    let config = &(Config {
        treat_doc_strings_as_comments: Some(true),
        ..Config::default()
    });
    

    let result = panic::catch_unwind(|| { language.parse_from_slice(buggy_input, config) });

    match result {
        Ok(_) => println!("Parsed successfully"),
        Err(_) => eprintln!("❌ Caught panic in `parse_from_slice`!"),
    }
}

fn run_4() {
    println!("run 4");

    // ? line 197 - 200, and 202 logical bug, 203 infi recursion ,same funtion
    let s = r#"
         q = "\u000B"
    "#;
    let data: toml::Value = toml::from_str(s).unwrap();
    println!("{:?}", data);
    println!("{}", toml::to_string(&data).unwrap());

    // ? line 201
    let s = r#"
        "\n" = 5
    "#;
    let data: toml::Value = toml::from_str(s).unwrap();
    println!("{:?}", data);
    match toml::to_string(&data) {
        Ok(serialized) => println!("{}", serialized),
        Err(e) => eprintln!("Error serializing TOML: {}", e),
    }

    // ? line 204, same bug as 203, but toml_edit, I reapeat the same function in toml
    // ! crashing input
    // let brackets = "[".repeat(20000);
    let brackets = "[".repeat(2);
    let input_string = format!("x={}", &brackets);
    let _: Result<toml::Value, _> = toml::from_str(&input_string);
}

fn run_5() {
    println!("run 5");
    // ! crashing input for line 208
    // let data = b"\x00\x01\x00\x00\x00\x0f\x00\x10\x00PTT-W\x002h\xd7\x81x\x00\
    // \x00\x00?L\xbaN\x00c\x9a\x9e\x8f\x96\xe3\xfeu\xff\x00\xb2\x00@\x03\x00\xb8\
    // cvt 5:\x00\x00\x00\xb5\xf8\x01\x00\x03\x9ckEr\x92\xd7\xe6\x98M\xdc\x00\x00\
    // \x03\xe0\x00\x00\x00dglyf\"\t\x15`\x00\x00\x03\xe0\x00\x00\x00dglyf\"\t\x15\
    // `\x00\x00\x00 \x00\x00\x00\xfc\x97\x9fmx\x87\xc9\xc8\xfe\x00\x00\xbad\xff\
    // \xff\xf1\xc8head\xc7\x17\xce[\x00\x00\x00\xfc\x00\x00\x006hhea\x03\xc6\x05\
    // \xe4\x00\x00\x014\x00\x00\x00$hmtx\xc9\xfdq\xed\x00\x00\xb5\xf8\x01\x00\x03\
    // \x9ckEr\x92\xd7\xe6\xdch\x00\x00\xc9d\x00\x00\x04 loca\x00M\x82\x11\x00\x00\
    // \x00\x06\x00\x00\x00\xa0maxp\x17\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 name\
    // \xf4\xd6\xfe\xad\x00OTTO\x00\x02gpost5;5\xe1\x00\x00\xb0P\x00\x00\x01\xf0perp%\
    // \xb0{\x04\x93D\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x01\x00\x00\xe1!yf%1\
    // \x08\x95\x00\x00\x00\x00\x00\xaa\x06\x80fmtx\x02\x00\x00\x00\x00\x00\x00\x00\
    // \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
    // \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00a\xcc\xff\
    // \xce\x03CCCCCCCCC\x00\x00\x00\x00\x00C\x00\x00\x00\x00\xb5\xf8\x01\x00\x00\x9c";

    // ! crashing input for line 209
    // let data = b"OTTO\x00\t\x00\x80\x00\x03\x00\x10CFF \xba\x8a\xb3\xe3\x00\x00\x03\
    // \xf0\x00\x00\x00[OS/2T\xe9R\xb6\x00\x00\x01\x00\x00\x00\x00`cmap\x00{\x01\xa6\
    // \x00\x00\x038\x00\x00\x00\x98head\xf0\xfal[\x00\x00\x00\x9c\x00\x00\x006hhea\x068\
    // \x02M\x00\x00\x00\xd4\x00\x00\x00$hmtx\x07)\x00\x00\x00\x00\x04L\x00\x00\x00\x0cmaxp\
    // \x00\x03P\x00\x00\x00\x00\xf8\x00\x00\x00\x06name\xf1+\xeb\xf6\x00\x00\x01`\x00\
    // \x00\x01\xd7post\xff\xb8\x002\x00\x00\x03\xd0\x00\x00\x00 \x00\x01\x00\x00\x00\
    // \x01\x00&\xe8xq\xb3_\x0f<\xf5\x00\x03\x03\xe8\x00\x00\x00\x00\xc7R\x94\x89\x00\
    // \x00\x00\x00\xc7R\x94\x89\x00\x00\x00\xf3\x03?\x01v\x00\x00\x00\x03\x00\x02\x00\
    // \x00\x00\x00\x00\x00\x00\x01\x00\x00\x02\xee\xff\x06\x00\t\x03A\x00\x00\x00\x02\
    // \x03?\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\
    // \x00\x00P\x00\x00\x03\x00\x00\x00\x02\x02c\x01\x90\x00\x05\x00\x00\x02\xbc\x02\
    // \x8a\x00\x00\x00\x8c\x02\xbc\x02\x8a\x00\x00\x01\xdd\x002\x00\xfa\x00\x00\x00\
    // \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\
    // \x00\x00\x00\x00\x00FHD\x00\x00@\x00 \x00-\x02\xee\xff\x06\x00\x00\x02\xf5\x00\
    // \xf3\x00\x00\x00\x01\x00\x00\x00\x00\x01\xf4\x02\xbc\x00\x00\x00 \x00\x00\x00\
    // \x00\x00\x10\x00\xc6\x00\x01\x00\x00\x00\x00\x00\x00\x00<\x00\x00\x00\x00\t\x00\
    // \x00\x00\x00\xf9\xff\xfd\xff\xc3\xff\xfe\xff\x00\x00\x00\x00\x02\x00\x07\x00>\
    // \x00\x00\x01\x00\x00\x00\x00\x03\x00\x11\x00E\x00\x01\x00\x00\x00\x00\x00\x04\
    // \x00\x02\x00<\x00\x01\x00\x00\x00\x00\x00\x05\x00\x05\x00V\x00\x01\x00\x00\x00\
    // \x00\x00\x06\x00\x02\x00<\x00\x01\x00\x00\x00\x00\x00\x10\x00\x02\x00<\x00\x01\
    // \x00\x00\x00\x00\x00\x11\x00\x07\x00>\x00\x03\x00\x01\x04\t\x00\x00\x00x\x00[\
    // \x00\x03\x00\x01\x04\t\x00\x01\x00\x04\x00\xd3\x00\x03\x00\x01\x04\t\x00\x02\x00\
    // \x0e\x00\xd7\x00\x03\x00\x01\x04\t\x00\x03\x00\"\x00\xe5\x00\x03\x00\x01\x04\t\
    // \x00\x1d\x00\x04\x00\xd3\x00\x03\x00\x01\x04\t\x00\x05\x00\n\x01\x07\x00\x03\x00\
    // \x01\x04\t\x00\x06\x00\x04\x00\xd3Generated in 2009 by FontLab Studio. Copyright info pending.PIRegularFONTLAB:OTFEXPORT1.000\
    // \x00G\x00e\x00n\x00e\x00r\x00a\x00t\x00e\x00d\x00 \x00i\x00n\x00 \x002\x000\x000\
    // \x009\x00 \x00b\x00y\x00 \x00F\x00o\x00n\x00t\x00L\x00a\x00b\x00 \x00S\x00t\x00u\
    // \x00d\x00i\x00o\x00.\x00 \x00C\x00o\x00p\x00y\x00r\x00i\x00g\x00h\x00t\x00 \x00i\
    // \x00n\x00f\x00o\x00 \x00p\x00e\x00n\x00d\x00i\x00n\x00g\x00.\x00P\x00I\x00R\x00e\
    // \x00g\x00u\x00l\x00a\x00r\x00F\x00O\x00N\x00T\x00L\x00A\x00B\x00:\x00O\x00T\x00F\
    // \x00E\x00X\x00P\x00O\x00R\x00T\x001\x00.\x000\x000\x000\x00\x00\x00\x00\x03\x00\
    // \x00\x00\x03\x00\x00\x00p\x00\x01\x00\x00\x00\x00\x00\x1c\x00\x03\x00\x01\x00\
    // \x00\x00p\x00\x06\x00T\x00\x00\x00\t\x00%\x00\x02\x00\x00\x00\x00\x00\x00\x00\
    // \x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
    // \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\
    // \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
    // \x00\x00\x00\x00\x01\x00\x04\x00(\x00\x00\x00\x06\x00\x04\x00\x01\x00\x02\x00 \
    // \x00-\xff\xff\x00\x00\x00 \x00-\xff\xff\xff\xe2\xff\xd4\x00\x01\x00\x00\x00\x00\
    // \x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\xff\xb5\x002\x00\x00\x00\x00\x00\x00\
    // \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x04\x01\x00\x01\
    // \x01\x01\x03PI\x00\x01\x01\x01\x1c\xf8\x10\x00\xf8\x1b\x02\xf8\x1b\x03\xf8\x18\
    // \x04\x8b\xf7\x87\xf9\xbf\x05\xf8\x0f\xd3\n\xc4\x11\x8e\xe3\x12\x00\x01\x01\x01\
    // \x03PI\x00\x00\x00\x00\x0e\x00\x01\x00\x03\x01\x04\x16\x01\x19\xf8\x88\xf0\x87\
    // \xf7\x17\x01\xf7\x87\x04\xf9\xd3\xf7\x17\xed\xf0\x0e\xd3\xf8\x88\x0e\x8b\x8b\x00\
    // \xf4\x06\x00\x01\x00\x03A\x00\x00\x01\xf4\x00\x00";

    let data = b"\x00\x01\x00\x00\x00\x0f\x00\x10\x00PTT-W\x002h\xd7\x81x\x00\"";
    match ttf_parser::Face::from_slice(data, 0) {
        Ok(face) => {
            let _ = face.outline_glyph(ttf_parser::GlyphId(0), &mut Builder);
        }
        Err(e) => eprintln!("Error parsing font: {:?}", e),
    }
}

struct Builder;

impl ttf_parser::OutlineBuilder for Builder {
    #[inline]
    fn move_to(&mut self, _: f32, _: f32) {
        panic!();
    }

    #[inline]
    fn line_to(&mut self, _: f32, _: f32) {
        panic!();
    }

    #[inline]
    fn quad_to(&mut self, _: f32, _: f32, _: f32, _: f32) {
        panic!();
    }

    #[inline]
    fn curve_to(&mut self, _: f32, _: f32, _: f32, _: f32, _: f32, _: f32) {
        panic!();
    }

    #[inline]
    fn close(&mut self) {
        panic!();
    }
}

fn run_6() {
    println!("run 6");
    let data = "1 KB";
    match data.parse::<ubyte::ByteUnit>() {
        Ok(byte_unit) => println!("Parsed byte unit: {:?}", byte_unit),
        Err(e) => eprintln!("Error parsing byte unit: {:?}", e),
    }
}

use unicode_segmentation::UnicodeSegmentation;
fn run_7() {
    println!("run 7");

    // ? line 211
    let s = "\u{1F938}\u{1F3FE}\u{1F3FE}";
    let forward = UnicodeSegmentation::graphemes(s, true).collect::<Vec<_>>();
    let forward_reversed = forward.into_iter().rev().collect::<Vec<_>>();
    let reverse = UnicodeSegmentation::graphemes(s, true).rev().collect::<Vec<_>>();
    assert_eq!(forward_reversed, reverse);

    // ? line 212
    let s =
        "j\u{FFFD}jjjjjjjjjjj\u{0489}\u{200D}\u{2764}jjjjjjjjj\u{0489}j\u{FFFD}\u{FFFD}\u{FFFD}\"jjjjjj\"jjD\u{0409}\u{0489}0\\f\u{FFFD}";
    let forward = s.split_word_bounds().collect::<Vec<_>>();
    let forward_reversed = forward.into_iter().rev().collect::<Vec<_>>();
    let reverse = s.split_word_bounds().rev().collect::<Vec<_>>();
    // ? assert would fail, that's the bug
    assert_eq!(forward_reversed, reverse);
}

fn run_9() {
    // ? line 214
    // ! crashing input
    // let url = "ftp:xn--f\u{34a}-PTP";
    let url = "www.example.com";
    let _ = url::Url::parse(url);

    // ? line 215
    // ! let u = url::Url::parse("p:/.//:/").unwrap();
    let result = url::Url::parse("p:/.//:/");
    match result {
        Ok(u) => {
            let s = u.as_str();
            assert_eq!(s, "p://:/"); // the `/.` was lost
            match url::Url::parse("p://:/") {
                Ok(parsed_url) => println!("Parsed URL: {}", parsed_url),
                Err(e) => eprintln!("Error parsing URL: {:?}", e),
            }
        }
        Err(e) => eprintln!("Error parsing URL: {:?}", e),
    }
}

fn run_10() {
    println!("run 10");
    let result = panic::catch_unwind(||uuid::Uuid::parse_str("F9168C5E-CEB2F4faaFB6BFF329BF39FA1E4").unwrap());
}


fn run_11() {
    println!("run 11");
    let x = vial::Request::from_reader(std::io::empty());
    match x {
        Ok(request) => {
            vial::util::percent_decode(request.path());
        }
        Err(e) => eprintln!("Error creating request: {:?}", e),
    }
}


fn run_12() {
    // ? line 219 - 223, same entry function
    println!("run 12");
    let data = b"";
    for _ in vobsub::subtitles(data) {
        // Just parse and ignore.
    }
}

use std::{mem, slice};
use std::os::unix::io::RawFd;
use wayland_commons::wire::{Message, ArgumentType};

unsafe fn convert_slice<T: Sized>(data: &[u8]) -> Option<&[T]> {
    let n = mem::size_of::<T>();

    // ✅ Prevent division by zero and unaligned memory issues
    if n == 0 || data.as_ptr().align_offset(n) != 0 || data.len() % n != 0 {
        return None; // Return None instead of crashing
    }

    Some(slice::from_raw_parts(
        data.as_ptr() as *const T,
        data.len() / n,
    ))
}

fn get_arg_types(data: &[u8]) -> Option<[ArgumentType; 16]> {
    use ArgumentType::*;

    if data.len() != 16 {
        return None; // Prevent panics due to incorrect input size
    }

    let mut res = [Int; 16];
    for i in 0..16 {
        res[i] = match data[i] & 0b111 {
            0 => Int,
            1 => Uint,
            2 => Fixed,
            3 => Str,
            4 => Object,
            5 => NewId,
            6 => Array,
            7 => Fd,
            _ => return None, // Avoid undefined behavior
        };
    }
    Some(res)
}

fn run_13() {
    println!("run 13");

    let data: &[u8] = &[
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, // RawFd data
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, // ArgumentType data
        0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, // Message data
    ];

    let fds = unsafe { convert_slice::<RawFd>(&data[..16]) };
    let args = get_arg_types(&data[16..32]);
    let data = unsafe { convert_slice::<u32>(&data[32..]) };

    if let (Some(fds), Some(args), Some(data)) = (fds, args, data) {
        let result = std::panic::catch_unwind(|| Message::from_raw(data, &args, fds));

        match result {
            Ok(_) => println!("✅ Message parsing succeeded."),
            Err(_) => eprintln!("❌ Caught panic in `Message::from_raw`, continuing execution."),
        }
    } else {
        eprintln!("❌ Invalid input detected, skipping Message::from_raw");
    }

    println!("🚀 Continuing execution after handling the error...");
}

fn run_14() {
    println!("run 14");

    // ! crashing input
    // let bytes = b"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xfe\xfe\xfe\xfe\xfe\t\x01\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xb1\n".to_vec();

    let bytes = b"\xff\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe\xfe".to_vec();
    let mut data = std::io::Cursor::new(bytes);
    let _ =  ws::Frame::parse(&mut data);
}

fn run_15() {

    // ? line 228-230, same function
    let decoder = yaxpeax_x86::amd64::InstDecoder::default();
    drop(decoder.decode_slice(&[98, 98, 101, 10]));
}

fn run_16() {
    // ! crashing input
    // let data = b"PK\x03\x04\n\x00\x00\x00\x00\x00\xe9p\xdaJ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x1c\x00zip/UT\t\x00\x03\xf5\xf8PY\"\xf9PYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x03\x04\x14\x00\x00\x00\x08\x00\xe9p\xdaJ\xf6\xe3\xf0\xa6\xd6\x00\x00\x00\x04\x18\x00\x00\r\x00\x1c\x00zip/.DS_StoreUT\t\x00\x03\xf5\xf8PY\xf5\xf8PYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00\xed\x981\n\xc2@\x10E\xff\xc4 \x01\x9b--\xf7\n\xde`\tz\x02/ (\xd8\x88\x91H\xacSy.\x8ff\xc2~Q4\x81X)\xfa\x1f\x0c\xaf\xc8\xcc&ivv\x16\x80\xe5\xd5f\x068\x00\x19\xa2qF\'\x19\xe3\x85\x84\xb6\x18\xcd\x1a\x15\x8e\xa7e\xb9\xdf\x15\xfbm\xf7Z/\xb4\xb5c\xacQ\xa0\xc4\xe1\xa9\xde\x06\xae!\x84\x10B\x88\xe1\xb0\xbff\x93\xcf~\x86\x10\xe2\x0bi\xf7\x07O\x07\xba\x8e6>O\xe8\xf4\xa1\xc6\xd1\x9e\x0et\x1dm\xccK\xe8\x94\xcehG{:\xd0u47-\xe3\xf0a|\xb3qB1G{:\xbc\xf5\xcbB\xfc\r\xa3(\xd7\xf6\xff\x05z\xe7\x7f!\xc4\x0fc\xe9|9\xcf\xd1\x7f\xe1\xd6\xf6Z\xdf\xc4\x8a9\x97[a\xcfA \x89\x17\x86S\xdc\xf3<\x1d\xe8:Z\x87\x01!>\xc1\x15PK\x03\x04\x14\x00\x00\x00\x08\x00\\g\xdaJ\x16\xd3\x86m\x9d\x00\x00\x00\xf7\x00\x00\x00\x0e\x00\x1c\x00zip/Cargo.tomlUT\t\x00\x03\xf0\xe8PYl\xf8PYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00\x85\x8f1\x0e\xc3 \x0cEw\x9f\x02\xb1\x07:W\xeaIP\x06\x08N@M\x08\xc2\x10\xa9\xa9z\xf7\x9a\xa1\xaa:U\x9e\xfe\xb7\x9f\xbfm\xb2\x9d\xeev\xc1\x11\x92\xddP\xdc\x84<c\x1e\xaa-\x0bV\x92p`\xa1\xb8\xa7\xee_\x14\x97\x84\xdc\xdc\x1a)\xb03\xdb\x95\x10\xc0x\xcc\x98<\xa6)\"\x8d\xc08\xf7\x9eb\x89\xb5S\xa1\xd6LW\xadY\x86\xe6\xd4\xb4oz;|B\xd2=\xa7\x90\x14/X\xa3\x9b\xdbyb\x19\xe8A\x7f\xe0\xd2\xa8\x0e}Z\xffP\x8aG\xfa*0\xc6\xc54~\xbf)h=\x1fmk\xf8(\xc5\xa1\xf0\x06PK\x03\x04\n\x00\x00\x00\x00\x00zh\xdaJ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0b\x00\x1c\x00zip/corpus/UT\t\x00\x03\x00\x00\x04\x18\x00\x00\r\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81>\x00\x00\x00zip/.DS_StoreUT\x05\x00\x03\xf5\xf8PYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x01\x02\x1e\x03\x14\x00\x00\x00\x08\x00\\g\xdaJ\x16\xd3\x86m\x9d\x00\x00\x00\xf7\x00\x00\x00\x0e\x00\x18\x00\x00\x00\x00\x00\x01\x00\x00\x00\xa4\x81[\x01\x00\x00zip/Cargo.tomlUT\x05\x00\x03\xf0\xe8PYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x01\x02\x1e\x03\n\x00\x00\x00\x00\x00zh\xdaJ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0b\x00\x18\x00\x00\x00\x00\x00\x00\x00\x10\x00\xedA@\x02\x00\x00zip/corpus/UT\x05\x00\x03\x18\xeaPYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x01\x02\x1e\x03\x14\x00\x00\x00\x08\x00zh\xdaJ\xcbL\xc0{\x07\x00\x00\x00K\x00\x00\x003\x00\x18\x00\x00\x00\x00\x00\x01\x00\x00\x00\xa4\x81\x85\x02\x00\x00zip/corpus/9fdad349dac578687a62907dd7ba4295801fa566UT\x05\x00\x03\x18\xeaPYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x01\x02\x1e\x03\x14\x00\x00\x00\x08\x00\x98h\xdaJ\xae2\xf2\xfa\xfd\x00\x00\x00\x97\x01\x00\x00\x0b\x00\x18\x00\x00\x00\x00\x00\x01\x00\x00\x00\xa4\x81\xf9\x02\x00\x00zip/read.rsUT\x05\x00\x03O\xeaPYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x01\x02\x1e\x03\n\x00\x00\x00\x00\x00\x01q\xdaJ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x18\x00\x00\x00\x00\x00\x00\x00\x10\x00\xed\xbf\xc4\xfb\xff\xff\x85\x96\x85/seeds/UT\x05\x00\x03\"\xf9PYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x01\x02\x1e\x03\x14\x00\x00\x00\x08\x00\xedp\xdaJj\x00\x88m\xb2\x00\x00\x00\x04\x18\x00\x00\x13\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x7f\x04\x00\x00zip/seeds/.DS_StoreUT\x05\x00\x03\xfd\xf8PYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x05\x06\x00\x00\x00\x00\x08\x00\x08\x00\xb5\x02\x00\x00~\x05\x00\x00\x00\x00";

    // ? line 231, 232, the same bug function while they have different commit hashs 
    println!("running run 16");
    let data = b"PK\x03\x04\n\x00\x00\x00\x00\x00\xe9p\xdaJ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x1c\x00zip/UT\t\x00\x03\xf5\xf8PY\"\xf9PYux\x0b\x00\x01\x04\xf5\x01\x00\x00\x04\x14\x00\x00\x00PK\x03\x04\x14\x00\x00\x00\x08\x00\xe9p\xdaJ\xf6\xe3\xf0\xa6\xd6\x00\x00\x00\x04\x18\x00\x00\r\x00\x1c\x00zip/.";

    let reader = std::io::Cursor::new(data);
    let mut archive = if let Ok(x) = zip::ZipArchive::new(reader) { x } else { return; };

    for i in 0..archive.len() {
        use std::io::prelude::*;

        let file = archive.by_index(i).unwrap();
        let _size = file.bytes().count();
    }


}